<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>blog.thesparktree.com</title>
   
   <link>https://blog.thesparktree.com</link>
   <description>Devops posts & guides about interesting tech like Docker, Letsencrypt, Chef, Angular, Automation, API's or other topics that you should know about. </description>
   <language>en-uk</language>
   <managingEditor> Jason Kulatunga</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Local Development with Wildcard DNS</title>
	  <link>/local-development-with-wildcard-dns</link>
	  <author>Jason Kulatunga</author>
	  <pubDate>2017-04-07T04:19:33-05:00</pubDate>
	  <guid>/local-development-with-wildcard-dns</guid>
	  <description><![CDATA[
	     <p>The holy-grail of local development is wildcard DNS: the ability to have <code class="highlighter-rouge">*.local.company.com</code> pointing to <code class="highlighter-rouge">localhost</code>, your development machine.
It doesn’t matter if you’re working on <code class="highlighter-rouge">website.local.company.com</code> or <code class="highlighter-rouge">api.local.company.com</code>, there’s no additional configuration necessary as you start working on new projects.</p>

<p>Unfortunately macOS doesn’t support wildcard entries in the <code class="highlighter-rouge">/etc/hosts</code> file – no OS does out of the box.</p>

<h2 id="dnsmasq">Dnsmasq</h2>

<p><a href="http://www.thekelleys.org.uk/dnsmasq/doc.html">Dnsmasq</a> is a tiny and incredibly popular DNS server that you can run locally, and supports wildcard domain resolution with very little configuration.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>brew install dnsmasq
</code></pre>
</div>

<p>Now lets setup the configuration directory and configure <code class="highlighter-rouge">dnsmasq</code> to resolve all of our development domains.</p>

<blockquote>
  <p>You’ll want to avoid the <code class="highlighter-rouge">*.dev</code> and <code class="highlighter-rouge">*.local</code> domains for development. <code class="highlighter-rouge">.dev</code> exists as a real <a href="https://newgtlds.icann.org/en/program-status/delegated-strings">TLD in the ICANN root</a>. <code class="highlighter-rouge">.local</code> is used by the <a href="https://support.apple.com/en-us/HT201275">Bonjour service</a> on macOS. I recommend using <code class="highlighter-rouge">*.local.companyname.com</code> or <code class="highlighter-rouge">*.lan</code></p>
</blockquote>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>mkdir -pv <span class="k">$(</span>brew --prefix<span class="k">)</span>/etc/

cat &gt;<span class="k">$(</span>brew --prefix<span class="k">)</span>/etc/dnsmasq.conf <span class="sh">&lt;&lt;EOL

# Add domains which you want to force to an IP address here.
# The example below send any host in *.local.company.com and *.lan to a local
# webserver.
address=/local.company.com/127.0.0.1
address=/lan/127.0.0.1

# Don't read /etc/resolv.conf or any other configuration files.
no-resolv
# Never forward plain names (without a dot or domain part)
domain-needed
# Never forward addresses in the non-routed address spaces.
bogus-priv

EOL
</span></code></pre>
</div>

<p>Then lets configure <code class="highlighter-rouge">launchd</code> start <code class="highlighter-rouge">dnsmasq</code> now and restart at startup:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo brew services start dnsmasq
</code></pre>
</div>

<p>Finally lets validate that our <code class="highlighter-rouge">dnsmasq</code> server is configured to respond to all subdomains of <code class="highlighter-rouge">local.company.com</code> by running:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>dig nested.test.local.company.com @127.0.0.1

; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; nested.test.local.company.com @127.0.0.1
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER<span class="sh">&lt;&lt;- opcode: QUERY, status: NOERROR, id: 64864
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0

;; QUESTION SECTION:
;nested.test.local.company.com.	IN	A

;; ANSWER SECTION:
nested.test.local.company.com. 0 IN	A	127.0.0.1

;; Query time: 0 msec
;; SERVER: 127.0.0.1#53(127.0.0.1)
;; WHEN: Sat Apr  8 11:15:17 2017
;; MSG SIZE  rcvd: 63
</span></code></pre>
</div>

<h2 id="integration-using-etcresolver">Integration using <code class="highlighter-rouge">/etc/resolver</code></h2>

<p>At this point we have a working DNS server, but it’s meaningless because macOS won’t use it for resolving any domains.</p>

<p>We can change this by adding configuration files in the <code class="highlighter-rouge">/etc/resolver</code> directory.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>sudo bash -c <span class="s1">'echo "nameserver 127.0.0.1" &gt; /etc/resolver/local.company.com'</span>
sudo bash -c <span class="s1">'echo "nameserver 127.0.0.1" &gt; /etc/resolver/lan'</span>
</code></pre>
</div>

<p>Each domain that we configured in <code class="highlighter-rouge">dnsmasq</code> should have a corresponding entry in <code class="highlighter-rouge">/etc/resolver/</code></p>

<p>Next, lets test that our resolver entries have been picked up by macOS.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>scutil --dns

...
resolver <span class="c">#8</span>
  domain   : local.company.com
  nameserver[0] : 127.0.0.1
  flags    : Request A records
Reachable, Directly Reachable Address
...
</code></pre>
</div>

<h2 id="fin">Fin</h2>

<p>Testing you new configuration is easy; just use ping check that you can now resolve your local subdomains:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="c"># Make sure you haven't broken your DNS.</span>
ping -c 1 www.google.com

<span class="c"># Check that .local.company.com &amp; .lan names work</span>
ping -c 1 this.is.a.test.local.company.com
ping -c 1 this.domain.does.not.exist.lan
</code></pre>
</div>

<p>This is useful in particular for developers of microservices: your orchestration platform can dynamically generate hostnames, and you won’t have to worry about your <code class="highlighter-rouge">/etc/hosts</code> file again.</p>

<h3 id="references">References</h3>
<ul>
  <li>http://asciithoughts.com/posts/2014/02/23/setting-up-a-wildcard-dns-domain-on-mac-os-x/</li>
  <li>https://gist.github.com/eloypnd/5efc3b590e7c738630fdcf0c10b68072</li>
  <li>https://passingcuriosity.com/2013/dnsmasq-dev-osx/</li>
  <li>http://serverfault.com/questions/118378/in-my-etc-hosts-file-on-linux-osx-how-do-i-do-a-wildcard-subdomain</li>
  <li>https://gist.github.com/ogrrd/5831371</li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
